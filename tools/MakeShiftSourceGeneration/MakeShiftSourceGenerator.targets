<Project InitialTargets="GenerateHttpConstructor">
  <UsingTask TaskName="HttpConstructorGenerator" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)/Microsoft.Build.Tasks.Core.dll">
    <Task>
      <Reference Include="$(ProjectRoot)/tools/MakeShiftSourceGeneration/libs/System.Memory.dll" />
      <Reference Include="$(ProjectRoot)/tools/MakeShiftSourceGeneration/libs/System.Text.Json.dll" />
      <Reference Include="$(ProjectRoot)/tools/MakeShiftSourceGeneration/libs/NuGet.Frameworks.dll" />
      <Using Namespace="System" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Reflection" />
      <Using Namespace="System.Text" />
      <Using Namespace="System.Text.Json" />
      <Using Namespace="Microsoft.Build.Utilities" />
      <Using Namespace="NuGet.Frameworks" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            #nullable enable
            const string codeTemplate =
"""
// <auto-generated/>

#nullable enable
namespace HyperSharp.Protocol
{
    public readonly partial record struct HyperStatus
    {
        #if {{NetVersion}}_OR_GREATER

        /// <inheritdoc cref="global::System.Net.HttpStatusCode.{{Code}}" />
        public static HyperStatus {{Code}}() => new(global::System.Net.HttpStatusCode.{{Code}}, new HyperHeaderCollection(), null);

        /// <inheritdoc cref="global::System.Net.HttpStatusCode.{{Code}}" />
        /// <param name="body">The body of the response.</param>
        public static HyperStatus {{Code}}(object? body) => new(global::System.Net.HttpStatusCode.{{Code}}, new HyperHeaderCollection(), body);

        /// <inheritdoc cref="global::System.Net.HttpStatusCode.{{Code}}" />
        /// <param name="headers">The headers of the response.</param>
        public static HyperStatus {{Code}}(HyperHeaderCollection headers) => new(global::System.Net.HttpStatusCode.{{Code}}, headers, null);

        /// <inheritdoc cref="global::System.Net.HttpStatusCode.{{Code}}" />
        /// <param name="headers">The headers of the response.</param>
        /// <param name="body">The body of the response.</param>
        public static HyperStatus {{Code}}(HyperHeaderCollection headers, object? body) => new(global::System.Net.HttpStatusCode.{{Code}}, headers, body);

        #endif
    }
}

""";
            string[] targetedFrameworks = "$(TargetFrameworks)".Split(';');

            string? dotnetRoot = Environment.GetEnvironmentVariable("DOTNET_ROOT");
            if (dotnetRoot is null)
            {
                BuildEngine.LogErrorEvent(new BuildErrorEventArgs("MakeShiftSourceGenerator", "DotNetRootNotFound", "The environment variable DOTNET_ROOT was not found.", "MakeShiftSourceGenerator.targets", 0, 0, 0, 0));
                return false;
            }

            Dictionary<NuGetFramework, (string, string)> nuGetFrameworks = new();
            foreach (string sdkVersion in Directory.GetDirectories(Path.Combine(dotnetRoot, "shared/Microsoft.NETCore.App/")))
            {
                string msBuildDependenciesJsonPath = Path.Combine(sdkVersion, "Microsoft.NETCore.App.runtimeconfig.json");
                if (!File.Exists(msBuildDependenciesJsonPath))
                {
                    BuildEngine.LogWarningEvent(new BuildWarningEventArgs("MakeShiftSourceGenerator", "MsBuildDependenciesJsonNotFound", $"The file {msBuildDependenciesJsonPath} was not found.", "MakeShiftSourceGenerator.targets", 0, 0, 0, 0));
                    continue;
                }

                JsonDocument? jsonDocument = JsonDocument.Parse(File.ReadAllText(msBuildDependenciesJsonPath));
                if (jsonDocument is null)
                {
                    BuildEngine.LogWarningEvent(new BuildWarningEventArgs("MakeShiftSourceGenerator", "MsBuildDependenciesJsonNotParsed", $"The file {msBuildDependenciesJsonPath} could not be parsed.", "MakeShiftSourceGenerator.targets", 0, 0, 0, 0));
                    continue;
                }

                // runtimeOptions.tfm
                if (!jsonDocument.RootElement.TryGetProperty("runtimeOptions", out JsonElement runtimeOptions) || !runtimeOptions.TryGetProperty("tfm", out JsonElement tfm))
                {
                    BuildEngine.LogWarningEvent(new BuildWarningEventArgs("MakeShiftSourceGenerator", "MsBuildDependenciesJsonNotParsed", $"The file {msBuildDependenciesJsonPath} was missing the expected \"runtimeOptions.tfm\" property.", "MakeShiftSourceGenerator.targets", 0, 0, 0, 0));
                    continue;
                }

                string? targetFrameworkMoniker = tfm.GetString();
                if (targetFrameworkMoniker is null)
                {
                    BuildEngine.LogWarningEvent(new BuildWarningEventArgs("MakeShiftSourceGenerator", "MsBuildDependenciesJsonNotParsed", $"The file {msBuildDependenciesJsonPath} was \"runtimeOptions.tfm\" property has an unexpected null value.", "MakeShiftSourceGenerator.targets", 0, 0, 0, 0));
                    continue;
                }
                else if (!targetedFrameworks.Any(framework => framework.StartsWith(targetFrameworkMoniker, StringComparison.OrdinalIgnoreCase)))
                {
                    BuildEngine.LogDebugEvent(new BuildMessageEventArgs($"Skipping target framework {targetFrameworkMoniker} because it is not targeted by the project.", "MakeShiftSourceGenerator.targets", "MakeShiftSourceGenerator", MessageImportance.Low));
                    continue;
                }

                nuGetFrameworks.Add(NuGetFramework.Parse(targetFrameworkMoniker), (msBuildDependenciesJsonPath, targetFrameworkMoniker));
            }

            foreach (KeyValuePair<NuGetFramework, (string, string)> kvp in nuGetFrameworks.OrderBy(framework => framework.Key, new NuGetFrameworkSorter()))
            {
                NuGetFramework nuGetFramework = kvp.Key;
                string msBuildDependenciesJsonPath = kvp.Value.Item1;
                string targetFrameworkMoniker = kvp.Value.Item2;

                Assembly assembly = Assembly.LoadFile(Path.Combine(Path.GetDirectoryName(msBuildDependenciesJsonPath), "System.Net.Primitives.dll"));
                string[] httpStatuses = Enum.GetNames(assembly.GetType("System.Net.HttpStatusCode")!);
                foreach (string httpStatus in httpStatuses)
                {
                    if(File.Exists($"$(ProjectRoot)/src/HyperSharp/Protocol/HyperStatus/HyperStatus.{httpStatus}.g.cs"))
                    {
                        continue;
                    }

                    StringBuilder stringBuilder = new(codeTemplate);
                    stringBuilder.Replace("{{NetVersion}}", targetFrameworkMoniker.Replace('.', '_').ToUpperInvariant());
                    stringBuilder.Replace("{{Code}}", httpStatus);
                    File.WriteAllText($"$(ProjectRoot)/src/HyperSharp/Protocol/HyperStatus/HyperStatus.{httpStatus}.g.cs", stringBuilder.ToString());
                }
            }
        ]]>
      </Code>
    </Task>
  </UsingTask>
  <Target Name="GenerateHttpConstructor" BeforeTargets="CoreCompile" Condition="!Exists('$(ProjectRoot)/src/HyperSharp/Protocol/HyperStatus/HyperStatus.OK.g.cs')" >
    <HttpConstructorGenerator />
  </Target>
</Project>